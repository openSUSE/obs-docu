<!DOCTYPE chapter
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>
<chapter version="5.1" xml:id="cha.obs.prjconfig"
 xmlns="http://docbook.org/ns/docbook"
 xmlns:xi="http://www.w3.org/2001/XInclude"
 xmlns:xlink="http://www.w3.org/1999/xlink" >
 <title>Build Configuration</title>
 <info/>

 <sect1 xml:id="sec.prjconfig.about">
  <title>About the Build Configuration</title>
  <para>
   Each project has a <firstterm>build configuration</firstterm> which
   defines the setup of the build system and the publish behaviour. Usually
   the distribution base is defining it and you do not need to change anything.
   However, when you change it, it can be used for the following reasons:
  </para>
  <remark>toms 2017-08-18: Add more reasons why it is needed</remark>
  <itemizedlist>
   <listitem>
    <para>
     Handle compatibility layers. <remark>toms 2017-08-18: more info needed!</remark>
    </para>
   </listitem>
   <listitem>
    <para>
     Switch on or off certain features during the build.
    </para>
   </listitem>
   <listitem>
    <para>
     Decide which package is installed during build.
    </para>
   </listitem>
   <listitem>
    <para>
     Resolve dependency problems like when there are multiple providers for a dependency:
    </para>
   </listitem>
   <listitem>
    <para>
     Handle user decisions like macro settings
    </para>
   </listitem>
   <listitem>
    <para>
     Modify publish behaviour, e.g. define metadata or filter binaries.
    </para>
   </listitem>
  </itemizedlist>
  <para>
   The build configuration can be stored in multiple places. Inside of OBS it
   can be stored only once per project. However, it is possible to define
   exceptions via if-conditions, for example per repository name or architecture.
   At the project level, the build configuration is sometimes referred to
   as the "project config", or "prjconf" for short. At build time, the configuration
   gets merged according to the repository path configuration defined in the project
   metadata. This resulting configuration can be requested using
   <command>osc buildconfig</command>.
   To view or edit the build configuration in projects, use one of the following
   methods
  </para>
  <itemizedlist>
   <listitem>
    <formalpara>
     <title>With &osccmd;</title>
     <para>Use <command>osc meta prjconf</command> in your working directory
     of your project.</para>
    </formalpara>
   </listitem>
   <listitem>
    <formalpara>
     <title>In the &obsa; Web UI</title>
     <para>Via the <guimenu>Project Config</guimenu> tab.</para>
    </formalpara>
   </listitem>
   <listitem>
    <formalpara>
     <title>With the &obsa; API</title>
     <para>Reachable via the <uri>/source/<replaceable>PROJECT</replaceable>/_config</uri> path.</para>
    </formalpara>
   </listitem>
   <listitem>
    <formalpara>
    <title>Via git/scmsync</title>
     <para>Store a file called '_config' in a git repository used via the scmsync mechanism
     for a project.</para>
    </formalpara>
   </listitem>
  </itemizedlist>
 </sect1>

 <sect1 xml:id="sec.prjconfig.syntax">
  <title>Configuration File Syntax</title>
  <para>
   The syntax is basically the same as in RPM spec files.
   However, it is independent of the packaging format used.
   The build configuration (prjconf) is parsed by &obsa;.
   This means, you can use RPM features like macros or conditions in the
   configuration. All lines (except conditionals) have the form:</para>
  <screen>keyword: arguments</screen>
  <para>
   Use the conditionals (%if or %ifarch) if a line should only be used in some
   condition.
  </para>
  <para>
   Many keywords, like `Require` or `BuildFlags`, do not replace existing
   data, but add to it. This means you can have multiple `BuildFlags`
   lines instead of having one line with all the flags you need.
  </para>
  <para>
   An exclamation mark `!` can be prepended to the argument to remove 
   an existing entry from the data.
  </para>
  <para>
   In the following list, the placeholder <replaceable>PACKAGES</replaceable>
   indicates a package base name (or names). When specifying multiple packages,
   separate their base names with spaces.
   For example, as a package name you need the base name like
   <package>gcc</package> but not the full name as in
   <package>gcc-1.2.3.i386.rpm</package>.
  </para>

  <para>
   The following list contains a list of allowed keywords in the build
   configuration (prjconf):
  </para>
  <variablelist xml:id="vl.prjconfig.keywords">
   <title>Available Keywords in Build Configuration</title>
   <!-- AssetsURL is not mentioned here as it has no effect in OBS -->
   <varlistentry>
    <term><parameter>BinaryType: <replaceable>TYPE</replaceable></parameter> (OBS 2.4 or later)</term>
    <listitem>
     <para>
      The binary type is the format of the packages that make up the build
      environment. This is usually set automatically depending on the recipe
      type and preinstall package list.
      Currently understood values are: `rpm`, `deb`, and `arch`.
     </para>
     <para>
      Sets the binary format used to set up the build
      environment. For example a package with spec build description may use
      and generate deb packages instead of RPMs. If no binary type is
      specified, OBS deduces it from the build recipe type. If the recipe type is
      also not set, OBS looks at the Preinstall package list for a hint.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>BuildEngine: <replaceable>ENGINE</replaceable></parameter></term>
    <listitem>
     <para>
       Use an alternative build engine. Examples are `mock` (for Fedora and
       Red Hat) and `debootstrap` (for Debian), `debbuild` (to build debian
       packages with spec files), `podman` (container builds).
       
       Here is an example config for `debbuild`:
	</para>
     <screen>Type: spec
Repotype: debian
Binarytype: deb
BuildEngine: debbuild
Support: pax debbuild</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>BuildFlags: <replaceable>FLAG</replaceable>:<replaceable>VALUE</replaceable></parameter></term>
    <listitem>
     <para>
      The <parameter>BuildFlags</parameter> keyword defines flags for the
      build process. The following values for FLAG are usable.</para>
     <variablelist>
      <varlistentry>
       <term><parameter>allowrootforbuild</parameter></term>
       <listitem>
        <para>
         Allow any package build to use root user for building. This still needs
         a marker inside of the build description to enable it.
        </para>
        </listitem>
      </varlistentry>
      <varlistentry>
       <term><parameter>vmfstype:TYPE</parameter></term>
       <listitem>
        <para>
         Defines a specific file system when building inside of a VM.
         Possible values are
         <literal>ext2</literal>, <literal>ext3</literal>,
         <literal>ext4</literal>, <literal>btrfs</literal>,
         <literal>xfs</literal>, <literal>reiserfs</literal> (v3).
        </para>
        </listitem>
      </varlistentry>
      <varlistentry>
       <term><parameter>vmfsoptions:OPTION</parameter></term>
       <listitem>
        <para>
          Sets options for file system creation. Currently only the `nodirindex`
          option is supported, which disables directory indexing for ext file
          systems. This makes file ordering inside of directories reproducible
          but may have a negative performance impact.
         <literal>vmfsoptions:nodirindex</literal>
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><parameter>kiwiprofile:PROFILE</parameter></term>
       <listitem>
        <para>Selects the profiles to build in kiwi appliance builds.</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><parameter>logidlelimit:SECONDS</parameter></term>
       <listitem>
         <para>Build jobs which do not create any output are aborted after some time.
               This flag can be used to modify the limit.</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><parameter>excludebuild:PACKAGE</parameter></term>
       <listitem>
	 <para>Exclude a package from building. If a package builds multiple flavors,
	       the corresponding flavor can be specified via the `package:flavor` syntax.</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><parameter>onlybuild:PACKAGE</parameter></term>
       <listitem>
         <para>DANGER: this may remove many build results when introduced the first time!
               It can be used to maintain a whitelist of packages to be built. All other packages
               will turn to excluded state and get removed if available.</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><parameter>useccache:PACKAGE</parameter></term>
       <listitem>
        <para>
         Configure usage of ccache when building the specified package.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><parameter>ccachetype:TYPE</parameter></term>
       <listitem>
        <para>
          Defines the ccache implementation, possible values are: ccache, sccache
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
        <term><parameter>obsgendiff</parameter></term>
       <listitem>
        <para>
          OBS can run an external program that has access to the current build
          and the previously successful result, e.g. to generate a difference or
          a changelog from the diff.
        </para>
        <para>
          OBS will run all scripts in
          <filename>/usr/lib/build/obsgendiff.d/</filename> on the build host
          (not in the <emphasis>%buildroot</emphasis>) when this flag is set.
          If one of the scripts fails to run or no scripts are found, then the
          overall build fails. I.e. if <literal>BuildFlags: obsgendiff</literal>
          is set, then you <emphasis>must</emphasis> provide at least one script
          in <filename>/usr/lib/build/obsgendiff.d/</filename>, otherwise your
          build will fail.
        </para>
        <para>
          A common use case for <literal>obsgendiff</literal> is to run <link
          xlink:href="https://github.com/openSUSE/release-compare">release-compare</link>
          after the build.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
        <term><parameter>setvcs</parameter></term>
       <listitem>
        <para>
          Add the SCM URL to binary results when the package sources are managed 
          via the scmsync mechanic. The url is written into the VCS tag of rpms
          when enabling this functionality.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
        <term><parameter>sbom:FORMAT</parameter></term>
       <listitem>
        <para>
	  OBS 2.11 can produce and publish additional SBOM (Software Bill Of Material) 
	  meta data by enabling this flag.
	  This is currently supported for container and kiwi images builds and includes
	  only data from installed rpm packages. Supported formats are spdx and cyclonedx.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
        <term><parameter>container-compression-format:FORMAT</parameter></term>
       <listitem>
        <para>
          Sets a compression format for container layers. Possible values are gzip, zstd,
          zstd:chunked. Every value other than gzip is only supported by podman and buildah.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
        <term><parameter>container-build-format:FORMAT</parameter></term>
       <listitem>
        <para>
          For podman container builds, it specifies the container config format. Possible values
          are 'docker' and 'oci'. The default is 'docker'. The 'docker' format allows a few
          extensions like ONBUILD, SHELL, DOMAINNAME, COMMENT, HEALTHCHECK amongst others.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>Conflict: <replaceable>PACKAGE</replaceable></parameter></term>
    <listitem>
     <para>Specify that a package must not be installed in the build environment.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>Conflict: <replaceable>PACKAGE_A</replaceable>:<replaceable>PACKAGE_B</replaceable></parameter></term>
    <listitem>
     <para>Specify a synthetic conflict between two given packages.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>Constraint: <replaceable>SELECTOR</replaceable> <replaceable>STRING</replaceable></parameter> (OBS 2.4 or later)</term>
    <listitem>
     <para>
      Define build constraints for build jobs. The selector is a
      colon-separated list which gets a string assigned. See the build job
      constraints page for details.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>DistMacro: <replaceable>NAME</replaceable> <replaceable>VALUE</replaceable></parameter></term>
    <listitem>
     <para>
      Define a macro to be used when parsing the spec files of packages.
      This is similar to using a `Macros:` section with the difference
      that the macro will not be written to the .rpmmacros file. It should
      therefore be used for macros that come from packages of the
      distributions.
      
      Note that the lines of the project config are macro expanded while
      parsing, so you have to use `%%` for a literal percent sign in
      the value.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>ExpandFlags: <replaceable>FLAG</replaceable></parameter></term>
    <listitem>
     <para>
      Flags which modify the behaviour during dependency resolution.
     </para>
      <variablelist>
       <varlistentry>
        <term><parameter>unorderedimagerepos</parameter> (OBS 2.10 or later)</term>
        <listitem>
           <para>The priority of repositories defined in an image build is usually important. This is to avoid switching repositories
           when the same package is available in multiple repositories. However, it might be wanted to ignore that and just
           pick the highest version. This can be achieved by defining this flag</para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><parameter>preinstallexpand</parameter></term>
        <listitem>
           <para>Preinstall also all dependencies of a preinstalled package.
                 This may increase the amount of preinstalled packages a lot.</para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><parameter>module:NAME-STREAM</parameter> (OBS 2.10.7 or later)</term>
        <listitem>
	<para>Enable Red Hat-specific module support in repo md repositories. By default, 
	      no module is used, so every module needed needs to be
              specified in the configuration. To remove a module,
              add an exclamation mark (<literal>!</literal>) as prefix.</para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><parameter>dorecommends</parameter></term>
        <listitem>
          <para>Try to install all recommended packages. Packages with dependency conflicts
                are ignored.</para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><parameter>dosupplements</parameter></term>
        <listitem>
          <para>Try to install all supplemented packages. Packages with dependency conflicts
                are ignored. This has the downside that new packages can cause different
                dependency expansion, so this should only be enabled for special use
                cases.  </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><parameter>ignoreconflicts</parameter></term>
        <listitem>
          <para>Ignore defined conflicts of packages. By default these are reported as unresolvable.
                This switch may be useful when packages get not installed in the build environment,
                but getting processed afterwards. That tool, e.g. some image building tool, must be
                able to handle the situation (e.g. by just using a subset of the packages).
                </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><parameter>kiwi-nobasepackages</parameter></term>
        <listitem>
          <para>Do not put the require/support/preinstall packages in the repositories
                offered to the kiwi build tool. This should have been the default.
           </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><parameter>keepfilerequires</parameter></term>
        <listitem>
          <para>Dependencies on files are only fulfilled if matching FileProvides are specified
                in the build configuration (prjconf). If those are missing, the dependency results in
                an "unresolvable" state for directly required files or in silent breaking of the
                dependency for indirectly required files. With this option, all file requires are
                honoured by default and lead to "unresolvable" if there are no matching FileProvides defined.
           </para>
        </listitem>
       </varlistentry>
      </variablelist>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>ExportFilter: <replaceable>REGEX</replaceable> <replaceable>ARCHITECTURES</replaceable></parameter></term>
    <listitem>
     <para>
      The export filter can be used to export build results from one
      architecture to others. This is required when one architecture needs
      packages from another architecture for building.
      The <replaceable>REGEX</replaceable> placeholder must match
      the resulting binary name of the package. It will export it to all listed
      scheduler architectures. Using a single dot will export it to the
      architecture which was used to build it. So not using a dot there will
      filter the package.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>FileProvides: <replaceable>FILE</replaceable> <replaceable>PACKAGES</replaceable></parameter></term>
    <listitem>
     <para> &obsa; ignores dependencies to files (instead of package names) by
      default. This is mostly done to reduce the amount of memory needed, as
      the package file lists take up a considerable amount of repository meta
      data. As a workaround, FileProvides can be used to tell the systems which
      packages contain a file. The File needs to have the full path.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>HostArch: <replaceable>HOST_ARCH</replaceable></parameter></term>
    <listitem>
     <para>
      This is used for cross builds. It defines the host architecture used
      for building, while the scheduler architecture remains the target
      architecture.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>Ignore: <replaceable>PACKAGE_OR_DEPENDENCY</replaceable></parameter></term>
    <listitem>
     <para>
      Ignore can be used to break dependencies. This can be useful to
      reduce the number of needed packages or to break cyclic dependencies. If a
      package is specified, all capabilities provided by the package are
      ignored.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>Ignore: <replaceable>ORIGIN_PACKAGE</replaceable>:<replaceable>PACKAGE_OR_DEPENDENCY</replaceable></parameter></term>
    <listitem>
     <para>
       Ignore a dependency coming from ORIGIN_PACKAGE. See the previous section
       for more details.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>Keep: <replaceable>PACKAGES</replaceable></parameter></term>
    <listitem>
     <para>
      To eliminate build cycles the to-be-built package are not installed
      by default, even when it is required. Keep can be used to overwrite this
      behavior. It is usually needed for packages like <systemitem>make</systemitem>
      that are used to build itself. Preinstalled packages are automatically kept, as the
      package installation program needs to work all the time.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>OptFlags: <replaceable>TARGET_ARCH</replaceable> <replaceable>FLAGS</replaceable></parameter> (RPM only)</term>
    <listitem>
     <para>
       Optflags exports compiler flags to the build by adding lines to rpm's
       <command>rpmrc</command> file. They will only have an effect when the spec file is using
       <command>$RPM_OPT_FLAGS</command> or <command>%{optflags}</command>. The target architecture may be set
       to <command>*</command> to affect all architectures.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>Order: <replaceable>PACKAG_A</replaceable>:<replaceable>PACKAGE_B</replaceable></parameter></term>
    <listitem>
     <para>
      The build script takes care about the installation order if they
      are defined via dependencies inside of the packages. However, there
      might be dependency loops (reported during setup of the build system) or
      missing dependencies. The <parameter>Order</parameter> statement can
      be used then to give a hint where to break the loop.
     </para>
     <para>The package in <replaceable>PACKAGE_A</replaceable> will get
      installed before the package in <replaceable>PACKAGE_B</replaceable>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>Patterntype: <replaceable>TYPE</replaceable></parameter></term>
    <listitem>
     <para>
       Defines the pattern format. Valid values are: none (default), ymp, comps.
       Multiple types can be specified.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>Prefer: <replaceable>PACKAGES</replaceable></parameter></term>
    <listitem>
     <para>
      In case multiple packages satisfy a dependency, the OBS system will
      complain about that situation. This is unlike like most package managing
      tools, which just pick one of the package. Because one of OBS' goal is to
      provide reproducible builds, it reports an error in this case instead of
      choosing a random package. The Prefer: tag lists packages to be preferred
      in case a choice exists. When the package name is prefixed with a dash,
      this is treated as a de-prefer.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>Prefer: <replaceable>ORIGIN_PACKAGE</replaceable>:<replaceable>PACKAGE</replaceable></parameter></term>
    <listitem>
     <para>
      It is possible to define the prefer only when the dependency comes
      from the specified originating package.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>Preinstall: <replaceable>PACKAGE</replaceable></parameter></term>
    <listitem>
     <para>
       This is used to specify packages needed to run the package installation
       program. These packages are unpacked so that the native installation
       program can be used to install the build environment.
       Included scripts are <emphasis>not</emphasis> executed during this phase. However, these
       packages will be re-installed later on including script execution.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>PublishFilter: <replaceable>REGEXP</replaceable> [<replaceable>REGEXP</replaceable>]</parameter></term>
    <listitem>
     <para>
      Limits the published binary packages in public repositories. Packages
      that match any <replaceable>REGEXP</replaceable> will not be put into
      the exported repository. There can be only one line of
      PublishFilter for historic reasons. However, multiple
      <replaceable>REGEXP</replaceable> can be defined.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>PublishFlags: <replaceable>FLAG</replaceable></parameter></term>
    <listitem>
     <para>
      Flags which modify the behaviour during repository generation.
     </para>
      <variablelist>
       <varlistentry>
        <term><parameter>artifacthub:TAG</parameter> (OBS 2.11 or later)</term>
        <listitem>
        <para>Publish a specific verified publisher identifier (aka repository id) for artifactub.io.
              This can be used to proof to be the publisher (aka maintainer) for containers from these
              OBS repositories.</para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><parameter>create_empty</parameter> (OBS 2.11 or later)</term>
        <listitem>
          <para>Create a repository even with no content, but with meta data.</para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><parameter>noearlykiwipublish</parameter> (OBS 2.11 or later)</term>
        <listitem>
          <para>Only publish kiwi build results after entire repository has finished building. Without this kiwi
                build results get published immediately after the build is finished.</para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><parameter>archsync</parameter> (OBS 2.11 or later)</term>
        <listitem>
	<para>Publish all architectures at the same time. This means that the publisher is waiting
              until the last architecture has finished building.</para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><parameter>nofailedpackages</parameter> (OBS 2.11 or later)</term>
        <listitem>
           <para>
            Block publishing if any build result was failed, broken, or unresolvable.
            That means, packages can be published for an architecture on which it builds,
            even if a package fails to build on another architecture.
           </para>
	   <para>
	    This is by default evaluated individually for each architecture. It can be
	    combined with the archsync flag when publishing should be blocked also when a failure
	    exists on any architecture.
           </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><parameter>singleexport</parameter> (OBS 2.11 or later)</term>
        <listitem>
           <para>
             If multiple packages contain different versions of a rpm package, only
             publish the one from the first package. If the project is of the type
             maintenance_release, this will be the package with the highest
             incident number.
           </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><parameter>withsbom</parameter> (OBS 2.11 or later)</term>
        <listitem>
          <para>Enables publishing of SBOM files (SPDX or CycloneDX format) (<literal>.cdx.json</literal> or <literal>.spdx.json</literal> files). Please note that the building of SBOM files usually needs to get enabled via a BuildFlags switch as well.</para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><parameter>withreports</parameter> (OBS 2.11 or later)</term>
        <listitem>
          <para>Also publish internal content tracking files (<literal>.report</literal> files).</para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><parameter>ympdist:NAME</parameter> (OBS 2.11 or later)</term>
        <listitem>
        <para>Defines the distversion to be used in group element of ymp files.
              This is used by the installer to check if the repository is suitable for the installed distribution.</para>
        </listitem>
       </varlistentry>
      </variablelist>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>RegistryURL: <replaceable>URL</replaceable></parameter></term>
    <listitem>
     <para>
       Define a url for the downloading of containers.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>Repotype:  <replaceable>TYPE[:OPTIONS]</replaceable></parameter></term>
    <listitem>
     <para> Defines the repository format for published repositories. Valid
      values are: none, rpm-md, suse, debian, hdlist2, arch, staticlinks and vagrant. The
      OPTIONS parameter depends on the repository type, for rpm-md the known
      options are 'legacy' to create the old rpm-md format, 'deltainfo' or
      'prestodelta' to create delta rpm packages, 'rsyncable' to use rsyncable
      gzip compression, 'sha512' to switch to SHA-512 instead of SHA-256 checksums
      in rpm-md meta data files. To split the debug packages in an own published repository the option
      <literal>splitdebug:<replaceable>REPOSITORY_SUFFIX</replaceable></literal>
      can be appended, e.g.
     </para>
     <screen>Repotype: rpm-md splitdebug:-debuginfo</screen>
    <para>
      This results in a debuginfo package repository being created in parallel to the
      package repository.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>RepoURL: <replaceable>[TYPE@]URL</replaceable></parameter></term>
    <listitem>
     <para>
       Define a url for the downloading of repository packages. Supported types
       are currently `arch`, `debian`, `hdlist2`, `rpmmd`, `suse`. If the
       type is not specified, it is guessed from the build type.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>Required: <replaceable>PACKAGE</replaceable></parameter></term>
    <listitem>
     <para>
      Specify a package that always is installed for package builds.
      A change in one of these packages triggers a new build.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>Runscripts: <replaceable>PACKAGES</replaceable></parameter></term>
    <listitem>
     <para>
      Defines the scripts of preinstalled packages which needs to be executed
      directly after the preinstall phase, but before installing the
      remaining packages.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>Substitute: <replaceable>OLD_DEPENDENCY</replaceable> <replaceable>NEW_DEPENDENCY</replaceable></parameter></term>
    <listitem>
     <para>
       It is possible to replace BuildRequires dependencies with other
       dependencies. This will have only an effect on directly BuildRequired
       packages, not on indirectly required packages.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>Support: <replaceable>PACKAGE</replaceable></parameter></term>
    <listitem>
     <para>
       Specify a package that always is installed for package builds.
       Unlike Required:, a change in one of these packages does not trigger an
       automatic rebuild.
     </para>
     <para>
      This is useful for packages that most likely do not influence the build
      result, for example <package>make</package> or <package>coreutils</package>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>Target: <replaceable>TARGET_ARCH</replaceable></parameter></term>
    <listitem>
     <para>Defines the target architecture. This can be used to build for i686
      on i586 schedulers for example. Please note that on rpm based systems just the architecture needs
      to be specified, but on debian systems the gnu triplet, for example arm-linux-gnueabihf.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>Target: <replaceable>GNU_TRIPLET</replaceable></parameter></term>
    <listitem>
     <para>Defines the target architecture. This can be used to build for i686
      on i586 schedulers for example. Please note that on rpm based systems just the architecture needs
      to be specified, but on debian systems the gnu triplet, for example arm-linux-gnueabihf.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>Type: <replaceable>TYPE</replaceable></parameter></term>
    <listitem>
     <para>
      Build recipe type. This is the format of the file which provides the
      build description. This gets usually autodetected, but in some rare cases
      it can be set here to either one of these: spec, dsc, kiwi, livebuild,
      arch, preinstallimage, mkosi.
     </para>
     <para>Defines the build recipe format. Valid values are currently: none, spec,
      dsc, arch, kiwi, preinstallimage. If no type is specified, OBS deduces a
      type from the binary type. </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>VMInstall: <replaceable>PACKAGE</replaceable></parameter></term>
    <listitem>
     <para>
      Like <parameter>Preinstall</parameter>, but these packages get only
      installed when a virtual machine like Xen or KVM is used for building.
      Usually  packages like <package>mount</package> are listed here.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>

 <sect1 xml:id="sec.prjconfig.ccache">
  <title>Building with ccache or sccache</title>
  <para>
    The usage of ccache or sccache can be enabled for each package by
    seting the useccache:PACKAGE build flag.
  </para>
  <para>
    The ccache package will automatically be installed and configured.
    The directory /.ccache/ will be configured as cache
    directory. To configure ccache, the file /.ccache/ccache.conf can be
    modified as part of the build process by the $BUILD_USER environment
    variable.
  </para>
  <para>
    In some cases, there is no archive for the current package, such as when
    the package was newly branched or when binaries were deleted. In these
    cases, the system will check whether there is a package of the same name
    built for the same architecture within one of the repositories
    configured in the project's meta configuration. If so, the archive of
    that package will be used. The repositories will be searched in the
    order they are configured in the meta configuration, starting from the
    top.
  </para>
  <para>
    An alternative way to enable caching based on build dependencies is to
    add "--enable-cache" as dependency, for example via a Substitute rule:
    <screen><command>
        Substitute: gcc-c++ gcc-c++ --enable-ccache
    </command></screen>
    This will always enable ccache when a direct build depdency to gcc-c++
    is required.
  </para>
  <para>
    It is also possible to set the type, eg:
    <screen><command>
        Substitute: cargo cargo --enable-ccache=sccache
    </command></screen>
  </para>
 </sect1>

 <sect1 xml:id="sec.prjconfig.macros">
  <title>Macro Definitions in the Build Configuration</title>
  <para>
    You can use rpm macro definitions in the build configuration (prjconf) to improve
    configurability. There are two types of macros that can be defined in the build
    configuration:
  </para>
  <itemizedlist>
   <listitem>
    <formalpara>
     <title>%define Macro Definitions</title>
     <para>
      Starting with a <systemitem class="macro">%define</systemitem> line
      are used in the build configuration only. These definitions are
      <emphasis>not</emphasis> available inside the build root.
     </para>
    </formalpara>
   </listitem>
   <listitem>
    <formalpara>
     <title>Macros: Macro Definitions</title>
     <para>
      Macros defined after a <systemitem class="macro">Macros:</systemitem> line
      are exported into the <filename>.rpmmacros</filename> file of the
      build root. As such, these macro definitions can be used in a spec
      file.
     </para>
    </formalpara>
   </listitem>
  </itemizedlist>

  <sect2 xml:id="sec.prjconfig.macros.define">
   <title>Macros for the Build Configuration Only</title>
   <para>
     To specify macros for the building process, use the %define
     keyword.
   </para>
   <para>
    For example, if you put this line in the prjconf
   </para>
   <screen>%define _with_pulseaudio 1</screen>
   <para>
    then the macro %_with_pulseaudio will expand to 1 only inside
    the build configuration.
   </para>
  </sect2>
  <sect2 xml:id="sec.prjconfig.macros.macrosection">
   <title>Macros Used in Spec Files Only</title>
   <para>
    To define the values of macros used in spec files, `%define` is <emphasis
    role="bold">not</emphasis> used. For this use case, either enclose the macro
    definitions between "Macros:"/":Macros" lines, or place them at the end of the
    prjconf file. All lines after a line containing the directive "Macros:" up
    to the end of the config, or up to a :Macros line, are used when parsing
    spec files and also made available to the build by copying them to the
    .rpmmacros file in the build root.
   </para>
   <para>
    The macro definition in the project configuration is located at the end
    and has the following structure:
   </para>
   <example>
    <title>Structure of a Macro Definition</title>
    <screen>Macros:
  # add your macro definitions
:Macros</screen>
   </example>
   <para>
    Everything that starts with a hash mark (<literal>#</literal>) is
    considered a comment.
   </para>
   <para>
    The macro definition itself are defined without a <literal>%define</literal>
    keyword. Start with <literal>%macroname</literal>, for example:
   </para>
   <screen>%_hardened_build 0</screen>
  </sect2>
 </sect1>
</chapter>
