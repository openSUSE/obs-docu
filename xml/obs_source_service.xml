<!DOCTYPE chapter
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>
<chapter version="5.1" xml:id="cha.obs.source_service"
 xmlns="http://docbook.org/ns/docbook"
 xmlns:xi="http://www.w3.org/2001/XInclude"
 xmlns:xlink="http://www.w3.org/1999/xlink" >
 <title>Using Source Services</title>
 <info/>

 <sect1 xml:id="sec.obs.sserv.about">
  <title>About Source Service</title>
  <para>
   Source Services are tools to validate, generate or modify sources in a
   trustable way. They are designed as smallest possible tools and can be
   combined following the powerful idea of the classic UNIX design.
  </para>
  <para>
   Source services allow:
  </para>
  <itemizedlist>
   <listitem>
    <para>
     Server side generated files are easy to identify and are not
     modifiable by the user. This way other user can trust them to be
     generated in the documented way without modifications.
    </para>
   </listitem>
   <listitem>
    <para>
     Generated files never create merge conflicts.
    </para>
   </listitem>
   <listitem>
    <para>
     Generated files are a separate commit to the user change.
    </para>
   </listitem>
   <listitem>
    <para>
     Services are runnable at any time without user commit.
    </para>
   </listitem>
   <listitem>
    <para>
     Services are runnable on server and client side in the same way.
    </para>
   </listitem>
   <listitem>
    <para>
     Services are safe. A source checkout and service run never harms
     the system of a user.
    </para>
   </listitem>
   <listitem>
    <para>
     Services avoid unnecessary commits.
     This means there are no time-dependent changes. In case the package
     already contains the same file, the newly generated file are dropped.
    </para>
   </listitem>
   <listitem>
    <para>
     Services running local or inside the build environment can get created,
     added and used by everybody.
    </para>
   </listitem>
   <listitem>
    <para>
     Services running in default or server side mode must be installed by
     the administrator of the &obsa; server.
    </para>
   </listitem>
   <listitem>
    <para>
     The use of a service can be defined per package or project wide.
    </para>
   </listitem>
  </itemizedlist>
  <para>
   For using source services you need (refer to <xref
    linkend="ex.obs.sserv.struct"/>):
  </para>
  <itemizedlist>
   <listitem>
    <para>
     An XML file named <filename>_service</filename>.
    </para>
   </listitem>
   <listitem>
    <para>
     A root element <tag>services</tag>.
    </para>
   </listitem>
   <listitem>
    <para>
     A <tag>service</tag> element which uses the specific service with
     optional parameters.
    </para>
   </listitem>
  </itemizedlist>
  <example xml:id="ex.obs.sserv.struct">
   <title>Structure of a <filename>_service</filename> File</title>
  <screen language="xml">&lt;services&gt; <co xml:id="co.obs.sserv.struct.services"/>
 &lt;service name="<replaceable>MY_SCRIPT</replaceable>"<co xml:id="co.obs.sserv.struct.name"/> mode="<replaceable>MODE</replaceable>"<co xml:id="co.obs.sserv.struct.mode"/>&gt;
  &lt;param name="<replaceable>PARAMETER1</replaceable>"&gt;<replaceable>PARAMETER1_VALUE</replaceable>&lt;/param&gt;<co xml:id="co.obs.sserv.struct.param"/>
 &lt;/service&gt;
&lt;/services&gt;</screen>
   <calloutlist>
    <callout arearefs="co.obs.sserv.struct.services">
     <para>
      The root element of a <filename>_service</filename> file.
     </para>
    </callout>
    <callout arearefs="co.obs.sserv.struct.name">
     <para>
      The service name. The service is a script that is stored in the
      <filename>/usr/lib/obs/service</filename> directory.
     </para>
    </callout>
    <callout arearefs="co.obs.sserv.struct.mode">
     <para>
      Mode of the service, see <xref linkend="sec.obs.sserv.mode"/>.
     </para>
    </callout>
    <callout arearefs="co.obs.sserv.struct.param">
     <para>
      One or more parameters which are passed to the script definied in
      <xref linkend="co.obs.sserv.struct.name"/>.
     </para>
    </callout>
   </calloutlist>
  </example>
  <para>
   The example above will execute the script:
  </para>
  <screen><command>/usr/lib/obs/service/<replaceable
   >MY_SCRIPT</replaceable></command> --<replaceable>PARAMETER1</replaceable> <replaceable>PARAMETER1_VALUE</replaceable> --outdir <replaceable>DIR</replaceable></screen>
  <remark>toms 2017-09-01: Maybe we should add a list of available
  services from /usr/lib/obs/service/?</remark>
 </sect1>

 <sect1 xml:id="sec.obs.sserv.mode">
  <title>Modes of Services</title>
  <para> Each service can be used in a mode defining when it should run
   and how to use the result. This can be done per package or globally for an
   entire project. </para>
<!--
   toms 2017-09-01:
   This is the table for the variablelist below. It's a good idea, but
   this table raises more question than it solves.
   Commenting for the time being.
  <table>
   <title>Service Modes</title>
   <tgroup cols="4">
    <colspec colnum="1" colwidth="1*"/>
    <colspec colnum="2" colwidth="2*"/>
    <colspec colnum="3" colwidth="2*"/>
    <colspec colnum="4" colwidth="4*"/>
    <thead>
     <row>
      <entry>Mode</entry>
      <entry>Runs locally</entry>
      <entry>Runs remotely</entry>
      <entry>Added File Handling</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>Default</entry>
      <entry>Before each build</entry>
      <entry>After each commit</entry>
      <entry>Generated file, prefixed with <filename>_service:</filename></entry>
     </row>
     <row>
      <entry><literal>trylocal</literal></entry>
      <entry>Before each build</entry>
      <entry>After each commit<remark>toms 2017-09-01: True?</remark>
      </entry>
      <entry>Committed as standard files but not named with 
       a <filename>_service:</filename> prefix</entry>
     </row>
     <row>
      <entry><literal>localonly</literal></entry>
      <entry>Before each build</entry>
      <entry>Never</entry>
      <entry>Committed as standard files but not named with 
       a <filename>_service:</filename> prefix</entry>
     </row>
     <row>
      <entry><literal>serveronly</literal></entry>
      <entry>Never</entry>
      <entry>Before each build</entry>
      <entry>Generated file, prefixed with <filename>_service:</filename><footnote>
       <para>
        This can be useful, when the service is not available or can not
        work on developer workstations.
       </para>
      </footnote><remark>toms 2017-09-01: ???</remark></entry>
     </row>
     <row>
      <entry><literal>buildtime</literal></entry>
      <entry>Before each build<footnote xml:id="fn.obs.sserv.mode.buildtime">
       <para>
        A side effect is that the service package is becoming a build
        dependency and must be available.
       </para>
      </footnote></entry>
      <entry>Before each build<xref linkend="fn.obs.sserv.mode.buildtime"/></entry>
      <entry></entry>
     </row>
     <row>
      <entry><literal>disabled</literal></entry>
      <entry>Never</entry>
      <entry>Never</entry>
      <entry><remark>toms 2017-09-01: </remark></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
-->
  <variablelist>
   <varlistentry>
    <term>Default Mode</term>
    <listitem>
     <para>
      The default mode of a service is to always run after each commit on
      the server side and locally before every local build.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>trylocal</literal> Mode</term>
    <listitem>
     <para>
      This mode is running the service locally. The result is committed
      as standard files and not named with a <literal>_service:</literal>
      prefix. Additionally, the service runs on the server by
      default. Usually the service should detect that the result is the same
      and skip the generated files. In case they differ, they get generated
      and added on the server.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>localonly</literal> Mode</term>
    <listitem>
     <para>
      This mode is running the service locally. The result gets committed
      as standard files and not named  with <literal>_service:</literal> prefix.
      The service is never running on the server side. It is also not
      possible to trigger it manually.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>serveronly</literal> Mode</term>
    <listitem>
     <remark>toms 2017-09-01: deprecated according to "osc service -h"?</remark>
     <para>
      The serviceonly mode is running the service on the service only. This
      can be useful, when the service is not available or can not work on
      developer workstations.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>buildtime</literal> Mode</term>
    <listitem>
     <para>
      The service is running inside of the build job, both for local and
      server side builds. A side effect is that the service package is
      becoming a build dependency and must be available. Every user can
      provide and use a service this way in their projects. The generated
      sources are not part of the source repository, but part of the
      generated source packages.
      Note that services requiring external network access are likely to
      fail in this mode, because such access is not available if the build
      workers are running in secure mode<phrase
       os="opensuse;novell"> (as is always the case at <link
        xlink:href="https://build.opensuse.org"/>)</phrase>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>disabled</literal> Mode</term>
    <listitem>
     <para>
      The disabled mode is neither running the service locally nor on the
      server side. It can be used to temporarily disable the service but keeping
      the definition as part of the service definition. Or it can be used to
      define the way how to generate the sources and doing so by manually calling
      <command>osc service disabledrun</command> The result will
      get committed as standard files again.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>

 <sect1 xml:id="sec.obs.sserv.validate">
  <title>Defining Services for Validation</title>
  <para>
   Source Services can be used to validate sources. This can be defined
   at different levels:
  </para>
  <itemizedlist>
   <listitem>
    <formalpara>
     <title>Per Package</title>
     <para>
      Useful when the packager wants to validate whether the downloaded
      sources are really from the original maintainer.
     </para>
    </formalpara>
   </listitem>
   <listitem>
    <formalpara>
     <title>Per Project</title>
     <para>
      Useful for applying project-wide policies which cannot be skipped for
      any package.
     </para>
    </formalpara>
   </listitem>
  </itemizedlist>

  <para>
   You can validate sources using either of two methods:
  </para>
  <remark>toms 2017-09-01: by sknorr FIXME: regarding the list:
  however, (based off my interpretation) the use cases seem to be different
  for those two methods: the first guards against corruptions that happen
  on the way between maintainer and you (i.e. rogue ISP). the second guards
  against corruptions between the source project and you (i.e. rogue
  maintainer). Interestingly, neither guards against both.
  </remark>
  <itemizedlist>
   <listitem>
    <para>
     By comparing checksums and metadata of the files in your repository
     with checksums and metadata as recorded by the maintainer.
    </para>
   </listitem>
   <listitem>
    <para>
     Alternatively, you can download the sources from a trusted location
     again and verify that they did not change.
    </para>
   </listitem>
  </itemizedlist>
 </sect1>

 <sect1 xml:id="sec.obs.sserv.create">
  <title>Creating Source Service Definitions</title>
  <para>
   Source services are defined in the <filename>_service</filename> file
   and are either part of the package sources or used project-wide.
   Project-wide services are stored under the <uri>_project</uri> package
   in file <filename>_service</filename>.
   package
  </para>
  <para> The <filename>_service</filename> file contains a list of services
   which get called in the listed order. Each service can define a list of
   parameters and a mode.
   The project wide services get called after the per package defined
   services.
   </para>
  <para>
   The <filename>_service</filename> file is in XML format and looks like this:
  </para>
  <screen language="xml">&lt;services&gt;
  &lt;service name="download_files" mode="trylocal" /&gt;
  &lt;service name="verify_file"&gt;
    &lt;param name="file"&gt;krabber-1.0.tar.gz&lt;/param&gt;
    &lt;param name="verifier"&gt;sha256&lt;/param&gt;
    &lt;param name="checksum"&gt;7f535a96a834b31ba2201a90c4d365990785dead92be02d4cf846713be938b78&lt;/param&gt;
  &lt;/service&gt;
  &lt;service name="update_source" mode="disabled" /&gt;
&lt;/services&gt;</screen>
  <para>
   With the example above, the services above are executed in the
   following order:
  </para>
  <orderedlist>
   <listitem>
    <para>
     Downloads the file via the <systemitem>download_files</systemitem>
     service using the URL from the Spec file.
     When using osc, the downloaded file gets committed as part of the commit.
    </para>
   </listitem>
   <listitem>
    <para>
     Compares the downloaded file (<filename>krabber-1.0.tar.gz</filename>)
     against the SHA256 checksum.
    </para>
   </listitem>
   <listitem>
    <para>
     When <command>osc service disabledrun</command> is run manually, update
     the source archive from an online source. In all other cases, ignore
     this part of the <filename>_service</filename> file.
    </para>
   </listitem>
  </orderedlist>
 </sect1>

 <sect1 xml:id="sec.obs.sserv.remove">
  <title>Removing a Source Service</title>
  <para> Sometimes it is useful to continued to work on generated files
   manually. In this situation the <filename>_service</filename> file needs
   to be dropped, but all
   generated files need to be committed as standard files. The &obsa;
   provides the <command>mergeservice</command> command for this. It can
   also be used via &osccmd; by calling
    <command>osc service merge</command>. </para>
 </sect1>

 <sect1 condition="tbd">
  <title>Interfaces for Using Source Services</title>
  <para><remark>tbd</remark></para>
 </sect1>
</chapter>
